defmodule OverDB.Protocol.V4.Frames.Frame do
  @moduledoc """
  Documentation for Frame.

  1) header_version :

    The version is a single byte that indicates both the direction of the message
      (request or response) and the version of the protocol in use. The most
      significant bit of version is used to define the direction of the message:
      0 indicates a request, 1 indicates a response. This can be useful for protocol
      analyzers to distinguish the nature of the packet from the direction in which
      it is moving. The rest of that byte is the protocol version (4 for the protocol
      defined in this document). In other words, for this version of the protocol,
      version will be one of:
        0x04    Request frame for this protocol version
        0x84    Response frame for this protocol version

      Please note that while every message ships with the version, only one version
      of messages is accepted on a given connection. In other words, the first message
      exchanged (STARTUP) sets the version for the connection for the lifetime of this
      connection.

  2) header_flags :

    Flags applying to this frame. The flags have the following meaning (described
    by the mask that allows selecting them):
      0x01: Compression flag. If set, the frame body is compressed. The actual
            compression to use should have been set up beforehand through the
            Startup message (which thus cannot be compressed; Section 4.1.1).
      0x02: Tracing flag. For a request frame, this indicates the client requires
            tracing of the request. Note that only QUERY, PREPARE and EXECUTE queries
            support tracing. Other requests will simply ignore the tracing flag if
            set. If a request supports tracing and the tracing flag is set, the response
            to this request will have the tracing flag set and contain tracing
            information.
            If a response frame has the tracing flag set, its body contains
            a tracing ID. The tracing ID is a [uuid] and is the first thing in
            the frame body. The rest of the body will then be the usual body
            corresponding to the response opcode.
      0x04: Custom payload flag. For a request or response frame, this indicates
            that a generic key-value custom payload for a custom QueryHandler
            implementation is present in the frame. Such a custom payload is simply
            ignored by the default QueryHandler implementation.
            Currently, only QUERY, PREPARE, EXECUTE and BATCH requests support
            payload.
            Type of custom payload is [bytes map] (see below).
      0x08: Warning flag. The response contains warnings which were generated by the
            server to go along with this response.
            If a response frame has the warning flag set, its body will contain the
            text of the warnings. The warnings are a [string list] and will be the
            first value in the frame body if the tracing flag is not set, or directly
            after the tracing ID if it is.

    The rest of flags is currently unused and ignored.

  3) header_stream :

    A frame has a stream id (a [short] value). When sending request messages, this
    stream id must be set by the client to a non-negative value (negative stream id
    are reserved for streams initiated by the server; currently all EVENT messages
    (section 4.2.6) have a streamId of -1). If a client sends a request message
    with the stream id X, it is guaranteed that the stream id of the response to
    that message will be X.

    This helps to enable the asynchronous nature of the protocol. If a client
    sends multiple messages simultaneously (without waiting for responses), there
    is no guarantee on the order of the responses. For instance, if the client
    writes REQ_1, REQ_2, REQ_3 on the wire (in that order), the server might
    respond to REQ_3 (or REQ_2) first. Assigning different stream ids to these 3
    requests allows the client to distinguish to which request a received answer
    responds to. As there can only be 32768 different simultaneous streams, it is up
    to the client to reuse stream id.

    Note that clients are free to use the protocol synchronously (i.e. wait for
    the response to REQ_N before sending REQ_N+1). In that case, the stream id
    can be safely set to 0. Clients should also feel free to use only a subset of
    the 32768 maximum possible stream ids if it is simpler for its implementation.

  4) header_opcode :

    An integer byte that distinguishes the actual message:
      0x00    ERROR
      0x01    STARTUP
      0x02    READY
      0x03    AUTHENTICATE
      0x05    OPTIONS
      0x06    SUPPORTED
      0x07    QUERY
      0x08    RESULT
      0x09    PREPARE
      0x0A    EXECUTE
      0x0B    REGISTER
      0x0C    EVENT
      0x0D    BATCH
      0x0E    AUTH_CHALLENGE
      0x0F    AUTH_RESPONSE
      0x10    AUTH_SUCCESS

    Messages are described in Section 4.

    (Note that there is no 0x04 message in this version of the protocol)

  5) header_length :

    A 4 byte integer representing the length of the body of the frame (note:
    currently a frame is limited to 256MB in length).

  """
  use Bitwise
  require Logger
  defstruct [:version, :flags, :stream_id, :opcode, :length, :body]

  @type version :: integer
  @type flags :: {atom, integer} | {Ignore.t, integer} | {Compression.t, module} | {CustomPayload.t, map} | {Warning.t, list} | {Tracing.t, integer}
  @type stream_id :: integer
  @type opcode :: integer | Startup.atom | Options.atom | Query.atom | Prepare.atom | Execute.atom | Batch.atom
  @type length :: integer
  @type body :: binary

  @type t :: %__MODULE__{version: version, flags: flags, stream_id: stream_id, opcode: opcode, length: length, body: body}

  alias OverDB.Protocol.V4.Frames.Requests.{Startup, AuthResponse, Batch, Execute, Options, Prepare, Query, Register, Encoder}
  alias OverDB.Protocol.V4.Frames.Responses.{AuthChallenge, Result, Ready, Authenticate, Supported, Event, AuthSuccess, Error}
  alias OverDB.Protocol.V4.Frames.Header.Flags.{Compression, Tracing, CustomPayload, Ignore, Warning}

  @request_version 0x04 # this indicates a request frame for this protocol version V4
  @response_version 0x84 # this indicates a response frame for this protocol version V4
  @header_length 9 # fixed size header (9 bytes)
  @ignore_flag Ignore.flag() # this is default flag for the header, see Ignore module inside the flags folder for more details

  @masked_flags %{
    Warning.flag() => %{warning: true},
    Ignore.flag() => %{ignore: true},
    Compression.flag() => %{compression: true},
    Tracing.flag() => %{tracing: true},
    CustomPayload.flag() => %{payload: true},
    Warning.flag() ||| Ignore.flag() => %{ignore: true, warnings: true},
    Warning.flag() ||| Compression.flag() => %{compression: true, warning: true},
    Warning.flag() ||| CustomPayload.flag() => %{payload: true, warning: true},
    Warning.flag() ||| Tracing.flag() => %{payload: true, tracing: true},
    Warning.flag() ||| Compression.flag() ||| Tracing.flag() ||| CustomPayload.flag() => %{warning: true, compression: true, tracing: true, payload: true},
    Warning.flag() ||| Compression.flag() ||| Tracing.flag() => %{warning: true, compression: true, tracing: true},
    Warning.flag() ||| Compression.flag() ||| CustomPayload.flag() => %{warning: true, compression: true, payload: true},
    Warning.flag() ||| Tracing.flag() ||| CustomPayload.flag() => %{warning: true, tracing: true, payload: true},
    Compression.flag() ||| Tracing.flag() ||| CustomPayload.flag() => %{compression: true, tracing: true, payload: true},
    Compression.flag() ||| Tracing.flag() => %{compression: true, tracing: true},
    Compression.flag() ||| CustomPayload.flag() => %{compression: true, payload: true},
    Tracing.flag() ||| CustomPayload.flag() => %{tracing: true, payload: true},
  }

  @request_opcodes %{
    :startup => Startup.opcode(),
    :options => Options.opcode(),
    :query => Query.opcode(),
    :prepare => Prepare.opcode(),
    :execute => Execute.opcode(),
    :register => Register.opcode(),
    :batch => Batch.opcode(),
    :auth_response => AuthResponse.opcode()
  }

  @response_opcodes %{
    Error.opcode() => :error,
    Ready.opcode() => :ready,
    Authenticate.opcode() => :authenticate,
    Supported.opcode() => :supported,
    Result.opcode() => :result,
    Event.opcode() => :event,
    AuthSuccess.opcode() => :auth_success,
    AuthChallenge.opcode() => :auth_challenge
  }

  defguard is_version(v) when v == @request_version or v == @response_version

  @spec version(integer) :: integer
  def version(version) when is_version(version), do: 4

  @spec length(atom) :: integer
  def length(:header), do: @header_length

  @spec length(binary) :: integer
  def length(<<_::5-bytes, body_length::32>> = _binary), do: body_length

  @spec type?(atom) :: integer
  defp type?(atom) when is_atom(atom), do: Map.fetch!(@request_opcodes, atom)

  @spec type?(integer) :: atom
  defp type?(opcode) when is_integer(opcode), do: Map.fetch!(@response_opcodes, opcode)

  @spec encode_flags(map) :: atom
  defp encode_flags(%{ignore: _}) do
    Ignore.flag()
  end

  @spec encode_flags(map) :: atom
  defp encode_flags(%{compression: _, tracing: _, payload: _payload}) do
    Compression.flag() ||| Tracing.flag() ||| CustomPayload.flag()
  end

  @spec encode_flags(map) :: atom
  defp encode_flags(%{compression: _, tracing: _}) do
    Compression.flag() ||| Tracing.flag()
  end

  @spec encode_flags(map) :: atom
  defp encode_flags(%{compression: _, payload: _payload}) do
    Compression.flag() ||| CustomPayload.flag()
  end

  @spec encode_flags(map) :: atom
  defp encode_flags(%{tracing: _, payload: _payload}) do
    Tracing.flag() ||| CustomPayload.flag()
  end

  @spec encode_flags(map) :: atom
  defp encode_flags(%{compression: _}) do
    Compression.flag()
  end

  @spec encode_flags(map) :: atom
  defp encode_flags(%{tracing: _}) do
    Tracing.flag()
  end

  @spec encode_flags(map) :: atom
  defp encode_flags(%{payload: _payload}) do
    CustomPayload.flag()
  end

  @spec decode_flags(integer) :: map
  defp decode_flags(flags) do
    Map.get(@masked_flags, flags)
  end

  # Frame Create function

  @spec create(opcode, list, map) :: t ###
  def create(opcode, body \\ [], flags \\ %{ignore: true}, stream_id \\ 0) when is_atom(opcode) do
    %__MODULE__{opcode: opcode, version: @request_version, flags: flags, stream_id: stream_id, body: body}
  end

  # TODO: adding handler logic for the frame warning flagged response which had a tracing id flag in the request, because it will affect the body
  # check warning flags section in the frames.md file
  # we should also check the custom_payload flag and see how we could implement it,
  @spec decode(binary, map) :: t
  def decode(buffer, flags \\ %{ignore: true})

  @spec decode(binary, map) :: t
  def decode(<<header::9-bytes, body::binary>>, flags) do
    decode(header, body, flags)
  end

  @spec decode(binary, binary, map) :: t
  def decode(<<@response_version, flags, stream_id::16, opcode, length::32>> = header, body , %{ignore: _} = _flag) when is_binary(header) and is_binary(body) do
    %__MODULE__{opcode: type?(opcode), version: 4, flags: decode_flags(flags), stream_id: stream_id, length: length, body: body}
  end

  @spec decode(binary, binary, map) :: t
  def decode(<<@response_version, flags, stream_id::16, opcode, length::32>> = header, body, %{compression: mod}) when is_binary(header) and is_binary(body) do
    flags = decode_flags(flags)
    body = is_compressed?(flags, mod, body)
    %__MODULE__{opcode: type?(opcode), version: 4, flags: flags, stream_id: stream_id, length: length, body: body}
  end

  @doc """
  this function it encodes frame for a given 'opcode' and 'flags'.

  Returns `list`.

  ## Examples

      iex> OverDB.Protocol.V4.Frames.Frame(%OverDB.Protocol.V4.Frames.Frame{version: 4, flags: {:ignore, 0}, stream_id: 0, opcode: :startup, body: []})
      [4, 0, <<0, 0>>, 1, <<0, 0, 0, 0>>, []]

  """
  @spec encode(t) :: list
  def encode(%__MODULE__{version: version, flags: %{ignore: _} = _flags, stream_id: stream_id, opcode: opcode, body: body} = _frame) do
    [version, @ignore_flag, <<stream_id::16>>, type?(opcode), <<IO.iodata_length(body)::32>>, body]
  end

  @spec encode(t) :: :ok
  def encode(%__MODULE__{version: _version, flags: %{compression: nil} = _flags, stream_id: _stream_id, opcode: _opcode, body: _body} = _frame) do
    Logger.error("you have passed a compression flag to the frame, but there's no module to compress, if you still wanna compress it then please pass a compress module otherwise don't set a flag")
  end

  @spec encode(t) :: list
  def encode(%__MODULE__{version: version, flags: %{compression: mod} = flags, stream_id: stream_id, opcode: opcode, body: body} = _frame) when is_atom(mod) do
    [version, encode_flags(flags), <<stream_id::16>>, type?(opcode), <<IO.iodata_length(body)::32>>, compress(mod, body)]
  end

  # NOTE: custom_payload not ready yet niether tested
  # custom_payload feature requires support from a query_handler in scylla side, so it's not usefull yet.
  # but for mirroringHandler you can use OverDB referrance feature in the engine.
  @spec encode(t) :: list
  def encode(%__MODULE__{version: version, flags: %{payload: map} = flags, stream_id: stream_id, opcode: opcode, body: body} = _frame) do
    payload = Encoder.bytes_map(map)
    body = body ++ payload
    [version, encode_flags(flags), <<stream_id::16>>, type?(opcode), <<IO.iodata_length(body)::32>>, body]
  end

  @spec push(t) :: binary
  def push(%__MODULE__{version: version, flags: flags, stream_id: _stream_id, opcode: opcode, body: body} = _frame) do
    [version, encode_flags(flags), type?(opcode), <<IO.iodata_length(body)::32>>, body] |> :erlang.list_to_binary()
  end

  @spec is_compressed?(atom, nil, binary) :: :ok
  defp is_compressed?(%{compression: _}, nil, _body) do
    Logger.error("received Frame have compression flag, but there's no module to decompress")
  end

  @spec is_compressed?(atom, module, binary) :: binary
  defp is_compressed?(%{compression: _}, module, body) do
    apply(module, :decompress, [body])
  end

  @spec is_compressed?(atom, module, binary) :: binary
  defp is_compressed?(_, _module, body) do
    Logger.warn("received Frame doesn't have compression flag, but you have passed a compression flag")
    body
  end

  @spec compress(module, binary) :: binary
  defp compress(module, body) do
    apply(module, :compress, [body])
  end

end
